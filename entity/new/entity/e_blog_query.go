// Code generated by taurus_go, DO NOT EDIT.

package entity

import (
	"context"
	"taurus_go_demo/entity/new/entity/internal"

	"github.com/yohobala/taurus_go/entity"
	"github.com/yohobala/taurus_go/entity/dialect"
	"github.com/yohobala/taurus_go/entity/entitysql"

	"taurus_go_demo/entity/new/entity/blog"
)

// BlogEntityQuery is the query action for the BlogEntity.
type BlogEntityQuery struct {
	config     *BlogEntityConfig
	ctx        *entitysql.QueryContext
	predicates []func(*entitysql.Predicate)
	scanner    []*internal.QueryScanner
	scannerTotal int
}

// First returns the first result of the query.
func (o *BlogEntityQuery) First(ctx context.Context) (*BlogEntity, error) {
	result, err := o.Single(ctx)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// NewBlogEntityQuery creates a new BlogEntityQuery.
func NewBlogEntityQuery(c *internal.Dialect, t entity.Tracker, ms *blogMutations) *BlogEntityQuery {
	return &BlogEntityQuery{
		config: &BlogEntityConfig{
			Dialect:    c,
			blogMutations: ms,
		},
		ctx: &entitysql.QueryContext{},
	}
}

func (o *BlogEntityQuery) Where(predicates ...func(*entitysql.Predicate)) *BlogEntityQuery {
	o.predicates = append(o.predicates, predicates...)
	return o
}

// Limit sets the limit of the query.
func (o *BlogEntityQuery) Limit(limit int) *BlogEntityQuery {
	o.ctx.Limit = &limit
	return o
}

// ToList returns the list of results of the query.
func (o *BlogEntityQuery) ToList(ctx context.Context) ([]*BlogEntity, error) {
	return o.sqlAll(ctx)
}

// Single returns the single result of the query.
func (o *BlogEntityQuery) Single(ctx context.Context) (*BlogEntity, error) {
	limit := 1
	o.ctx.Limit = &limit
	return o.sqlSingle(ctx)
}

func (o *BlogEntityQuery) sqlSingle(ctx context.Context) (*BlogEntity, error) {
	var (
		spec = o.querySpec()
		res  = o.config.New()
	)
	switch res := res.(type) {
	case *BlogEntity:
	spec.Scan = func(rows dialect.Rows, fields []entitysql.ScannerField) error {
		builder := entitysql.NewScannerBuilder(o.scannerTotal)
		builder.Append(0,res.scan(fields)...)
		return rows.Scan(builder.Flatten()...)
	}
	if err := entitysql.NewQuery(ctx, o.config.Driver, spec); err != nil {
		return nil, err
	}
	if err := res.setUnchanged(); err != nil {
		return nil, err
	}
	return res, nil
	default:
		return nil, entity.Err_0100030006
	}
}

func (o *BlogEntityQuery) sqlAll(ctx context.Context) ([]*BlogEntity, error) {
	var (
		spec = o.querySpec()
		res  = []*BlogEntity{}
	)
	spec.Scan = func(rows dialect.Rows, fields []entitysql.ScannerField) error {
		e := o.config.New()
		switch e := e.(type) {
		case *BlogEntity:
			builder := entitysql.NewScannerBuilder(o.scannerTotal)
			builder.Append(0,e.scan([]entitysql.ScannerField{})...)
			for _, s := range o.scanner {
				e.createRel(builder, s)
			}

			if err := rows.Scan(builder.Flatten()...); err != nil {
				return err
			} else {
				res = append(res, e)
				return nil
			}
		default:
			return entity.Err_0100030006
		}
	}
	if err := entitysql.NewQuery(ctx, o.config.Driver, spec); err != nil {
		return nil, err
	}
	for _, e := range res {
		if err := e.setUnchanged(); err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (o *BlogEntityQuery) querySpec() *entitysql.QuerySpec {
	s := entitysql.NewQuerySpec(blog.Entity, blog.Columns)
	if o.ctx.Limit != nil {
		s.Limit = *o.ctx.Limit
	}
	if fields := o.ctx.Fields; len(fields) > 0 {
		s.Entity.Columns = make([]entitysql.FieldName, 0, len(fields))
		s.Entity.Columns = append(s.Entity.Columns, fields...)
	}
	if ps := o.predicates; len(ps) > 0 {
		s.Predicate = func(p *entitysql.Predicate) {
			for _, f := range ps {
				f(p)
			}
		}
	}
	return s
}
