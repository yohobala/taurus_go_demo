// Code generated by taurus_go/entity, DO NOT EDIT.

package entity

import (
	"context"
	"taurus_go_demo/entity/new/entity/geo_demo"
	"taurus_go_demo/entity/new/entity/internal"

	"github.com/zodileap/taurus_go/entity"
	"github.com/zodileap/taurus_go/entity/dialect"
	"github.com/zodileap/taurus_go/entity/entitysql"
)

// GeoEntityQuery is the query action for the GeoEntity.
type GeoEntityQuery struct {
	config       *geoentityConfig
	ctx          *entitysql.QueryContext
	predicates   []entitysql.PredicateFunc
	rels         []geoentityRel
	order        []geo_demo.OrderTerm
	scanner      []*internal.QueryScanner
	scannerTotal int
}

// First returns the first result of the query.
func (o *GeoEntityQuery) First(ctx context.Context) (*GeoEntity, error) {
	result, err := o.Single(ctx)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// newGeoEntityQuery creates a new GeoEntityQuery.
func newGeoEntityQuery(c *internal.Dialect, t entity.Tracker, ms *geoentityMutations) *GeoEntityQuery {
	return &GeoEntityQuery{
		config: &geoentityConfig{
			Dialect:            c,
			geoentityMutations: ms,
		},
		ctx:          &entitysql.QueryContext{},
		predicates:   []entitysql.PredicateFunc{},
		rels:         []geoentityRel{},
		order:        []geo_demo.OrderTerm{},
		scanner:      []*internal.QueryScanner{},
		scannerTotal: 0,
	}
}

func (o *GeoEntityQuery) Where(predicates ...entitysql.PredicateFunc) *GeoEntityQuery {
	o.predicates = append(o.predicates, predicates...)
	return o
}

// Limit sets the limit of the query.
func (o *GeoEntityQuery) Limit(limit int) *GeoEntityQuery {
	o.ctx.Limit = &limit
	return o
}

func (o *GeoEntityQuery) Order(term ...geo_demo.OrderTerm) *GeoEntityQuery {
	o.order = append(o.order, term...)
	return o
}

func (o *GeoEntityQuery) Include(rels ...geoentityRel) *GeoEntityQuery {
	o.rels = append(o.rels, rels...)
	return o
}

// ToList returns the list of results of the query.
func (o *GeoEntityQuery) ToList(ctx context.Context) ([]*GeoEntity, error) {
	return o.sqlAll(ctx)
}

// Single returns the single result of the query.
func (o *GeoEntityQuery) Single(ctx context.Context) (*GeoEntity, error) {
	limit := 1
	o.ctx.Limit = &limit
	return o.sqlSingle(ctx)
}

func (o *GeoEntityQuery) sqlSingle(ctx context.Context) (*GeoEntity, error) {
	var (
		spec = o.querySpec()
		res  *GeoEntity
	)
	spec.Scan = func(rows dialect.Rows, fields []entitysql.ScannerField) error {
		e := o.config.New()
		switch e := e.(type) {
		case *GeoEntity:
			builder := entitysql.NewScannerBuilder(o.scannerTotal + 1)
			builder.Append(0, e.scan(fields)...)
			for _, s := range o.scanner {
				e.createRel(builder, s)
			}
			if err := rows.Scan(builder.Flatten()...); err != nil {
				return err
			} else {
				res = e
				return nil
			}
		default:
			return entity.Err_0100030006
		}
	}
	if err := entitysql.NewQuery(ctx, o.config.Driver, spec); err != nil {
		return nil, err
	}
	if res != nil {
		if err := res.setUnchanged(); err != nil {
			return nil, err
		}
	}
	for _, r := range o.rels {
		r.reset()
	}
	return res, nil
}

func (o *GeoEntityQuery) sqlAll(ctx context.Context) ([]*GeoEntity, error) {
	var (
		spec = o.querySpec()
		res  = []*GeoEntity{}
	)
	spec.Scan = func(rows dialect.Rows, fields []entitysql.ScannerField) error {
		e := o.config.New()
		switch e := e.(type) {
		case *GeoEntity:
			builder := entitysql.NewScannerBuilder(o.scannerTotal + 1)
			builder.Append(0, e.scan([]entitysql.ScannerField{})...)
			for _, s := range o.scanner {
				e.createRel(builder, s)
			}

			if err := rows.Scan(builder.Flatten()...); err != nil {
				return err
			} else {
				res = mergeGeoEntity(res, e)
				return nil
			}
		default:
			return entity.Err_0100030006
		}
	}
	if err := entitysql.NewQuery(ctx, o.config.Driver, spec); err != nil {
		return nil, err
	}
	for _, e := range res {
		if err := e.setUnchanged(); err != nil {
			return nil, err
		}
	}
	for _, r := range o.rels {
		rel := r
		rel.reset()
	}
	return res, nil
}

func (o *GeoEntityQuery) querySpec() *entitysql.QuerySpec {
	s := entitysql.NewQuerySpec(geo_demo.Entity, geo_demo.Columns)
	if o.ctx.Limit != nil {
		s.Limit = *o.ctx.Limit
	}
	if fields := o.ctx.Fields; len(fields) > 0 {
		s = entitysql.NewQuerySpec(geo_demo.Entity, fields)
	}
	for i := range s.Entity.Columns {
		switch geo_demo.Columns[i] {
		case geo_demo.FieldID.Name:
			var a *geoDemo_ID = new(geoDemo_ID)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldID.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldPoint.Name:
			var a *geoDemo_Point = new(geoDemo_Point)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldPoint.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldLineString.Name:
			var a *geoDemo_LineString = new(geoDemo_LineString)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldLineString.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldPolygon.Name:
			var a *geoDemo_Polygon = new(geoDemo_Polygon)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldPolygon.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiPoint.Name:
			var a *geoDemo_MultiPoint = new(geoDemo_MultiPoint)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiPoint.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiLineString.Name:
			var a *geoDemo_MultiLineString = new(geoDemo_MultiLineString)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiLineString.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiPolygon.Name:
			var a *geoDemo_MultiPolygon = new(geoDemo_MultiPolygon)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiPolygon.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldCircularString.Name:
			var a *geoDemo_CircularString = new(geoDemo_CircularString)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldCircularString.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldPointJson.Name:
			var a *geoDemo_PointJson = new(geoDemo_PointJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldPointJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldLineStringJson.Name:
			var a *geoDemo_LineStringJson = new(geoDemo_LineStringJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldLineStringJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldPolygonJson.Name:
			var a *geoDemo_PolygonJson = new(geoDemo_PolygonJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldPolygonJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiPointJson.Name:
			var a *geoDemo_MultiPointJson = new(geoDemo_MultiPointJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiPointJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiLineStringJson.Name:
			var a *geoDemo_MultiLineStringJson = new(geoDemo_MultiLineStringJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiLineStringJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		case geo_demo.FieldMultiPolygonJson.Name:
			var a *geoDemo_MultiPolygonJson = new(geoDemo_MultiPolygonJson)
			fieldSpace := entitysql.NewFieldSpec(geo_demo.FieldMultiPolygonJson.Name)
			fieldSpace.NameFormat = a.SqlSelectFormat()
			s.Entity.Columns[i] = fieldSpace
		}
	}
	if ps := o.predicates; len(ps) > 0 {
		s.Predicate = func(p *entitysql.Predicate) {
			for _, f := range ps {
				f(p)
			}
		}
	}
	if rs := o.rels; len(rs) > 0 {
		s.Rels = make([]entitysql.Relation, 0, len(rs))
		s.Orders = append(s.Orders, geo_demo.ByPrimary)
		for _, r := range rs {
			rel := r
			s.Rels = append(s.Rels, func(s *entitysql.Selector) {
				o.scanner = o.addRels(s, s.Table(), rel, o.scanner)
			})
		}
	}
	for _, o := range o.order {
		s.Orders = append(s.Orders, func(order *entitysql.Order) {
			o.Apply(order)
		})
	}
	return s
}

func (o *GeoEntityQuery) addRels(s *entitysql.Selector, t *entitysql.SelectTable, rel rel, scanner []*internal.QueryScanner) []*internal.QueryScanner {
	desc, children, config := rel.Desc()
	join := entitysql.AddRelBySelector(s, t, desc)
	_, tableNum := join.GetAs()
	qs := internal.QueryScanner{Config: config, Children: []*internal.QueryScanner{}, TableNum: tableNum}
	scanner = append(scanner, &qs)
	o.scannerTotal++
	if len(children) > 0 {
		for _, c := range children {
			qs.Children = o.addRels(s, join, c, qs.Children)
		}
	}
	return scanner
}
