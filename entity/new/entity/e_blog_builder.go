// Code generated by taurus_go/entity, DO NOT EDIT.

package entity

import (
	"context"
	"taurus_go_demo/entity/new/entity/blog"
	"taurus_go_demo/entity/new/entity/internal"
	"time"

	"github.com/zodileap/taurus_go/entity"
	"github.com/zodileap/taurus_go/entity/dialect"
	"github.com/zodileap/taurus_go/entity/entitysql"
)

// blogentityBuilder is a builder for the BlogEntity entity.
//
// The builder is used to create, update, and delete BlogEntity entities.
type blogentityBuilder struct {
	config      *blogentityConfig
	tracker     entity.Tracker
	Id          blog.PredID // Id Blog primary key
	Uuid        blog.PredUUID
	Description blog.PredDescription
	CreatedTime blog.PredCreatedTime
	// ByID configures the query to sort results based on the 'id' field of the entity.
	// Sorting entities in ascending order by default.
	ByID blog.ByID
	// ByUUID configures the query to sort results based on the 'uuid' field of the entity.
	// Sorting entities in ascending order by default.
	ByUUID blog.ByUUID
	// ByDescription configures the query to sort results based on the 'description' field of the entity.
	// Sorting entities in ascending order by default.
	ByDescription blog.ByDescription
	// ByCreatedTime configures the query to sort results based on the 'created_time' field of the entity.
	// Sorting entities in ascending order by default.
	ByCreatedTime blog.ByCreatedTime

	// Posts configures the query to include data from the 'post' table.
	// The method modifies the existing query to include a LEFT JOIN clause.
	// Posts be used as an argument to the Include method。
	Posts *postentityRelation
}

// newBlogEntityBuilder creates a new BlogEntityBuilder .
func newBlogEntityBuilder(c *blogentityConfig, t entity.Tracker, Posts postentityRelation) *blogentityBuilder {
	return &blogentityBuilder{
		config:  c,
		tracker: t,
		Posts:   &Posts,
	}
}

// Create creates a new UserEntity，and add it to the tracker.
// Required parameters are fields that have no default value but are required,
// and options are fields that can be left empty by calling WithFieldName.
func (b *blogentityBuilder) Create(uuid string, options ...func(*BlogEntity)) (*BlogEntity, error) {
	e := b.config.New()
	switch t := e.(type) {
	case *BlogEntity:
		return t.create(uuid, options...)
	default:
		return nil, entity.Err_0100030006
	}
}

func (b *blogentityBuilder) Remove(e *BlogEntity) error {
	if e.config.Mutation == nil {
		return nil
	}
	return e.remove()
}

// First returns the first BlogEntity.
func (s *blogentityBuilder) First(ctx context.Context) (*BlogEntity, error) {
	query := s.initQuery()
	return query.First(ctx)
}

func (s *blogentityBuilder) ToList(ctx context.Context) ([]*BlogEntity, error) {
	query := s.initQuery()
	return query.ToList(ctx)
}

func (s *blogentityBuilder) Include(rels ...blogentityRel) *BlogEntityQuery {
	query := s.initQuery()
	return query.Include(rels...)
}

func (s *blogentityBuilder) Order(o ...blog.OrderTerm) *BlogEntityQuery {
	query := s.initQuery()
	return query.Order(o...)
}

func (s *blogentityBuilder) Where(conditions ...entitysql.PredicateFunc) *BlogEntityQuery {
	query := s.initQuery()
	return query.Where(conditions...)
}

// WithDescription sets the "description" field of the BlogEntity.
func (s *blogentityBuilder) WithDescription(description string) func(*BlogEntity) {
	return func(e *BlogEntity) {
		e.Description.Set(description)
	}
}

// WithCreatedTime sets the "created_time" field of the BlogEntity.
func (s *blogentityBuilder) WithCreatedTime(createdtime time.Time) func(*BlogEntity) {
	return func(e *BlogEntity) {
		e.CreatedTime.Set(createdtime)
	}
}

// Exec executes all the blogentityMutations for the BlogEntity.
func (s *blogentityBuilder) Exec(ctx context.Context, tx dialect.Tx) error {
	if len(s.config.blogentityMutations.Addeds) > 0 {
		e := s.config.blogentityMutations.Get(entity.Added)
		n := newBlogEntityCreate(s.config.Dialect, e...)
		if err := n.create(ctx, tx); err != nil {
			return err
		}
	}
	if len(s.config.blogentityMutations.Modifieds) > 0 {
		e := s.config.blogentityMutations.Get(entity.Modified)
		n := newBlogEntityUpdate(s.config.Dialect, e...)
		if err := n.update(ctx, tx); err != nil {
			return err
		}
	}
	if len(s.config.blogentityMutations.Deleteds) > 0 {
		e := s.config.blogentityMutations.Get(entity.Deleted)
		n := newBlogEntityDelete(s.config.Dialect, e...)
		if err := n.delete(ctx, tx); err != nil {
			return err
		}
	}
	return nil
}

func (s *blogentityBuilder) initQuery() *BlogEntityQuery {
	return newBlogEntityQuery(s.config.Dialect, s.tracker, s.config.blogentityMutations)
}

// blogentityMutations is a collection of BlogEntity mutation.
type blogentityMutations struct {
	Detacheds  map[string]*BlogEntity
	Unchangeds map[string]*BlogEntity
	Deleteds   map[string]*BlogEntity
	Modifieds  map[string]*BlogEntity
	Addeds     map[string]*BlogEntity
}

// newBlogEntityMutations creates a new mutations.
func newBlogEntityMutations() *blogentityMutations {
	return &blogentityMutations{
		Detacheds:  make(map[string]*BlogEntity),
		Unchangeds: make(map[string]*BlogEntity),
		Deleteds:   make(map[string]*BlogEntity),
		Modifieds:  make(map[string]*BlogEntity),
		Addeds:     make(map[string]*BlogEntity),
	}
}

// Get returns all the BlogEntity in the specified state.
func (ms *blogentityMutations) Get(state entity.EntityState) []*BlogEntity {
	switch state {
	case entity.Detached:
		s := make([]*BlogEntity, 0, len(ms.Detacheds))
		for _, m := range ms.Detacheds {
			s = append(s, m)
		}
		return s
	case entity.Unchanged:
		s := make([]*BlogEntity, 0, len(ms.Unchangeds))
		for _, m := range ms.Unchangeds {
			s = append(s, m)
		}
		return s
	case entity.Deleted:
		s := make([]*BlogEntity, 0, len(ms.Deleteds))
		for _, m := range ms.Deleteds {
			s = append(s, m)
		}
		return s
	case entity.Modified:
		s := make([]*BlogEntity, 0, len(ms.Modifieds))
		for _, m := range ms.Modifieds {
			s = append(s, m)
		}
		return s
	case entity.Added:
		s := make([]*BlogEntity, 0, len(ms.Addeds))
		for _, m := range ms.Addeds {
			s = append(s, m)
		}
		return s
	}
	return nil
}

// SetEntityState sets the state of the entity.
func (ms *blogentityMutations) SetEntityState(e *BlogEntity, state entity.EntityState) error {
	m := e.config.Mutation
	ms.set(e, state)
	if err := internal.SetEntityState(m, state); err != nil {
		return err
	}
	return nil
}

// ChangeEntityState attempts to set the desired entity state,
// but will not do so if the conditions are not met.
func (ms *blogentityMutations) ChangeEntityState(m *entity.Mutation, state entity.EntityState) {
	e := ms.getEntity(m)
	ms.set(e, state)
	if err := internal.SetEntityState(m, state); err != nil {
		return
	}
}

// getEntity returns the entity in the specified state.
func (ms *blogentityMutations) getEntity(m *entity.Mutation) *BlogEntity {
	key := m.Key()
	switch m.State() {
	case entity.Detached:
		return ms.Detacheds[key]
	case entity.Unchanged:
		return ms.Unchangeds[key]
	case entity.Deleted:
		return ms.Deleteds[key]
	case entity.Modified:
		return ms.Modifieds[key]
	case entity.Added:
		return ms.Addeds[key]
	}
	return nil
}

// Set sets the entity in the specified state.
func (ms *blogentityMutations) set(e *BlogEntity, state entity.EntityState) {
	m := e.config.Mutation
	key := m.Key()
	switch m.State() {
	case entity.Detached:
		delete(ms.Detacheds, key)
	case entity.Unchanged:
		delete(ms.Unchangeds, key)
	case entity.Deleted:
		delete(ms.Deleteds, key)
	case entity.Modified:
		delete(ms.Modifieds, key)
	case entity.Added:
		delete(ms.Addeds, key)
	}
	if state >= 0 {
		switch state {
		case entity.Detached:
			ms.Detacheds[key] = e
		case entity.Unchanged:
			ms.Unchangeds[key] = e
		case entity.Deleted:
			ms.Deleteds[key] = e
		case entity.Modified:
			ms.Modifieds[key] = e
		case entity.Added:
			ms.Addeds[key] = e
		}
	}
}
