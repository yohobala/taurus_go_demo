// Code generated by taurus_go/entity, DO NOT EDIT.

package entity

import (
	"fmt"
	"taurus_go_demo/entity/new/entity/internal"
	"taurus_go_demo/entity/new/entity/post"

	"github.com/yohobala/taurus_go/entity"
	"github.com/yohobala/taurus_go/entity/entitysql"
)

type PostEntity struct {
	internal.Entity
	config *postEntityConfig

	// ID Post primary key
	ID *postID

	Content *postContent

	BlogID *postBlogID

	AuthorID *postAuthorID

	Blog *BlogEntity

	Author *AuthorEntity
}

// postEntityConfig holds the configuration for the PostEntity.
type postEntityConfig struct {
	internal.EntityConfig
	*internal.Dialect
	*entity.Mutation
	*postEntityMutations
	name string
}

func newPostEntityConfig(c *internal.Dialect) *postEntityConfig {
	return &postEntityConfig{
		Dialect:             c,
		postEntityMutations: newPostEntityMutations(),
		name:                "post",
	}
}

// New creates a new PostEntity, but does not add tracking.
func (c *postEntityConfig) New() internal.Entity {
	b := entity.NewMutation(entity.Detached)
	e := &PostEntity{
		config: &postEntityConfig{
			Mutation:            b,
			Dialect:             c.Dialect,
			postEntityMutations: c.postEntityMutations,
		},
	}
	e.setState(entity.Detached)
	e.ID = newPostID(e.config)
	e.Content = newPostContent(e.config)
	e.BlogID = newPostBlogID(e.config)
	e.AuthorID = newPostAuthorID(e.config)
	return e
}

func (c *postEntityConfig) Desc() internal.EntityConfigDesc {
	return internal.EntityConfigDesc{
		Name: c.name,
	}
}

// String implements the fmt.Stringer interface.
func (e *PostEntity) String() string {
	return fmt.Sprintf("{ ID: %v, Content: %v, BlogID: %v, AuthorID: %v, Blog: %v, Author: %v}",
		e.ID,
		e.Content,
		e.BlogID,
		e.AuthorID,
		e.Blog,
		e.Author,
	)
}

// State returns the state of the PostEntity.
func (e *PostEntity) State() entity.EntityState {
	return e.config.State()
}

// remove removes the PostEntity from the database.
func (e *PostEntity) remove() error {
	return e.setState(entity.Deleted)
}

// create creates a new PostEntity and adds tracking.
func (e *PostEntity) create(content string, blog_id int64, author_id int64, options ...func(*PostEntity)) (*PostEntity, error) {
	e.setState(entity.Added)
	e.Content.Set(content)
	e.BlogID.Set(blog_id)
	e.AuthorID.Set(author_id)
	for _, option := range options {
		option(e)
	}
	return e, nil
}

// setUnchanged sets the state of the PostEntity to unchanged.
func (e *PostEntity) setUnchanged() error {
	return e.setState(entity.Unchanged)
}

// setState sets the state of the PostEntity.
func (e *PostEntity) setState(state entity.EntityState) error {
	return e.config.postEntityMutations.SetEntityState(e, state)
}

// scan scans the database for the PostEntity.
func (e *PostEntity) scan(fields []entitysql.ScannerField) []any {
	if len(fields) == 0 {
		args := make([]any, len(post.Columns))
		for i, c := range post.Columns {
			switch c.String() {
			case post.FieldID.Name.String():
				v := e.ID
				v.Set(*new(int64))
				args[i] = v
			case post.FieldContent.Name.String():
				v := e.Content
				v.Set(*new(string))
				args[i] = v
			case post.FieldBlogID.Name.String():
				v := e.BlogID
				v.Set(*new(int64))
				args[i] = v
			case post.FieldAuthorID.Name.String():
				v := e.AuthorID
				v.Set(*new(int64))
				args[i] = v
			}
		}
		return args
	} else {
		args := make([]any, len(fields))
		for i := range fields {
			switch fields[i].String() {
			case post.FieldID.Name.String():
				v := e.ID
				v.Set(*new(int64))
				args[i] = v
			case post.FieldContent.Name.String():
				v := e.Content
				v.Set(*new(string))
				args[i] = v
			case post.FieldBlogID.Name.String():
				v := e.BlogID
				v.Set(*new(int64))
				args[i] = v
			case post.FieldAuthorID.Name.String():
				v := e.AuthorID
				v.Set(*new(int64))
				args[i] = v
			}
		}
		return args
	}
}

func (e *PostEntity) createRel(buidler *entitysql.ScannerBuilder, scanner *internal.QueryScanner) {
	switch scanner.Config.Desc().Name {
	case "blog":
		blogEntity := scanner.Config.New().(*BlogEntity)
		buidler.Append(scanner.TableNum-1, blogEntity.scan([]entitysql.ScannerField{})...)
		e.Blog = blogEntity
		for _, c := range scanner.Children {
			blogEntity.createRel(buidler, c)
		}
	case "author":
		authorEntity := scanner.Config.New().(*AuthorEntity)
		buidler.Append(scanner.TableNum-1, authorEntity.scan([]entitysql.ScannerField{})...)
		e.Author = authorEntity
		for _, c := range scanner.Children {
			authorEntity.createRel(buidler, c)
		}
	}
}

func mergePostEntity(es []*PostEntity, e *PostEntity) []*PostEntity {
	if e == nil {
		return es
	}
	if len(es) == 0 {
		es = append(es, e)
	} else {
		v := es[len(es)-1]

		if e.ID.Get() != nil {
			if v.ID.Get() != nil && *v.ID.Get() == *e.ID.Get() {
				blogs := mergeBlogEntity([]*BlogEntity{v.Blog}, e.Blog)
				if len(blogs) > 0 {
					v.Blog = blogs[0]
				}
				authors := mergeAuthorEntity([]*AuthorEntity{v.Author}, e.Author)
				if len(authors) > 0 {
					v.Author = authors[0]
				}
			} else {
				es = append(es, e)
			}
		}
	}
	return es
}
