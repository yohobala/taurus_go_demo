// Code generated by taurus_go, DO NOT EDIT.

package entity

import (
	"fmt"
	"taurus_go_demo/entity/new/entity/internal"

	"github.com/yohobala/taurus_go/entity"
	"github.com/yohobala/taurus_go/entity/entitysql"

	"taurus_go_demo/entity/new/entity/author"
)

type AuthorEntity struct {
	internal.Entity
	config *AuthorEntityConfig

	// ID Author primary key
	ID *AuthorID

	Name *AuthorName

	Post *PostEntity
}

// AuthorEntityConfig holds the configuration for the AuthorEntity.
type AuthorEntityConfig struct {
	internal.EntityConfig
	*aothorMutations
	*entity.Mutation
	*internal.Dialect
	name string
}

func NewAuthorConfig(c *internal.Dialect) *AuthorEntityConfig {
	return &AuthorEntityConfig{
		Dialect:    c,
		aothorMutations: newAuthorMutations(),
		name: "author",
	}
}

func (c *AuthorEntityConfig) New() internal.Entity {
	b := entity.NewMutation(entity.Detached)
	e := &AuthorEntity{
		config: &AuthorEntityConfig{
			Mutation:  b,
			Dialect:    c.Dialect,
			aothorMutations: c.aothorMutations,
		},
	}
	e.setState(entity.Detached)
	e.ID = newAuthorID(e.config)
	e.Name = newAuthorName(e.config)
	return e
}

func (c *AuthorEntityConfig) Desc() internal.EntityConfigDesc {
	return internal.EntityConfigDesc{
		Name: c.name,
	}
}

// String implements the fmt.Stringer interface.
func (e *AuthorEntity) String() string {
	return fmt.Sprintf("{ ID: %v, Name: %v, Post: %v}",
		e.ID,
		e.Name,
		e.Post,
	)
}

// State returns the state of the AuthorEntity.
func (e *AuthorEntity) State() entity.EntityState {
	return e.config.State()
}

// remove removes the AuthorEntity from the database.
func (e *AuthorEntity) remove() error {
	return e.setState(entity.Deleted)
}

// create creates a new AuthorEntity and adds tracking.
func (e *AuthorEntity) create(name string, options ...func(*AuthorEntity)) (*AuthorEntity, error) {
	e.setState(entity.Added)
	e.Name.Set(name)
	for _, option := range options {
		option(e)
	}
	return e, nil
}

// setUnchanged sets the state of the AuthorEntity to unchanged.
func (e *AuthorEntity) setUnchanged() error {
	return e.setState(entity.Unchanged)
}

// setState sets the state of the AuthorEntity.
func (e *AuthorEntity) setState(state entity.EntityState) error {
	return e.config.aothorMutations.SetEntityState(e, state)
}

// scan scans the database for the AuthorEntity.
func (e *AuthorEntity) scan( fields []entitysql.ScannerField) []any {
	if len(fields) == 0 {
		args := make([]interface{}, len(author.Columns))
		for i, c := range author.Columns {
			switch c.String() {
			case author.FieldID.Name.String():
				args[i] = e.ID
			case author.FieldName.Name.String():
				args[i] = e.Name
			}
		}
		return args
	} else {
		args := make([]interface{}, len(fields))
		for i := range fields {
			switch fields[i].String() {
			case author.FieldID.Name.String():
				args[i] = e.ID
			case author.FieldName.Name.String():
				args[i] = e.Name
			}
		}
		return args
	}
}

func (e *AuthorEntity) createRel(buidler *entitysql.ScannerBuilder, scanner *internal.QueryScanner) {
	switch scanner.Config.Desc().Name {
	case "post":
		post := scanner.Config.New().(*PostEntity)
		buidler.Append(scanner.TableNum - 1, post.scan([]entitysql.ScannerField{})...)
		e.Post = post
		for _, c := range scanner.Children {
			post.createRel(buidler, c)
		}
	}
}

func mergeAuthorEntity(es []*AuthorEntity, e *AuthorEntity) []*AuthorEntity {
	if e == nil{
		return es
	}
	if len(es) == 0 {
		es = append(es, e)
	}else{
		v := es[len(es) - 1]
		if e.ID.Get() != nil {
			if v.ID.Get() != nil && *v.ID.Get() == *e.ID.Get() {
			posts := mergePostEntity([]*PostEntity{v.Post}, e.Post)
			if len(posts) > 0 {
				v.Post = posts[0]
			}
		}else{
			es = append(es, e)
		}
	}
	}
	return es
}