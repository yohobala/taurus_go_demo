// Code generated by taurus_go/entity, DO NOT EDIT.

package entity

import (
	"fmt"
	"taurus_go_demo/entity/new/entity/geo_demo"
	"taurus_go_demo/entity/new/entity/internal"

	"github.com/zodileap/taurus_go/datautil/geo"
	"github.com/zodileap/taurus_go/entity"
	"github.com/zodileap/taurus_go/entity/entitysql"
)

// Geo的类型测试
type GeoEntity struct {
	internal.Entity     `json:"-"`
	config              *geoentityConfig
	Id                  *geoDemo_ID                  // Id 主键。
	Point               *geoDemo_Point               // Point 点
	LineString          *geoDemo_LineString          // LineString 线
	Polygon             *geoDemo_Polygon             // Polygon 多边形
	MultiPoint          *geoDemo_MultiPoint          // MultiPoint 多点
	MultiLineString     *geoDemo_MultiLineString     // MultiLineString 多线
	MultiPolygon        *geoDemo_MultiPolygon        // MultiPolygon 多多边形
	CircularString      *geoDemo_CircularString      // CircularString 圆弧
	PointJson           *geoDemo_PointJson           // PointJson 点
	LineStringJson      *geoDemo_LineStringJson      // LineStringJson 线
	PolygonJson         *geoDemo_PolygonJson         // PolygonJson 多边形
	MultiPointJson      *geoDemo_MultiPointJson      // MultiPointJson 多点
	MultiLineStringJson *geoDemo_MultiLineStringJson // MultiLineStringJson 多线
	MultiPolygonJson    *geoDemo_MultiPolygonJson    // MultiPolygonJson 多多边形
}

// geoentityConfig holds the configuration for the GeoEntity.
type geoentityConfig struct {
	internal.EntityConfig
	*internal.Dialect
	*entity.Mutation
	*geoentityMutations
	name string
}

func newGeoEntityConfig(c *internal.Dialect) *geoentityConfig {
	return &geoentityConfig{
		Dialect:            c,
		geoentityMutations: newGeoEntityMutations(),
		name:               "geo_demo",
	}
}

// New creates a new GeoEntity, but does not add tracking.
func (c *geoentityConfig) New() internal.Entity {
	b := entity.NewMutation(entity.Detached)
	e := &GeoEntity{
		config: &geoentityConfig{
			Mutation:           b,
			Dialect:            c.Dialect,
			geoentityMutations: c.geoentityMutations,
		},
	}
	e.setState(entity.Detached)
	e.Id = newGeoDemo_ID(e.config)
	e.Point = newGeoDemo_Point(e.config)
	e.LineString = newGeoDemo_LineString(e.config)
	e.Polygon = newGeoDemo_Polygon(e.config)
	e.MultiPoint = newGeoDemo_MultiPoint(e.config)
	e.MultiLineString = newGeoDemo_MultiLineString(e.config)
	e.MultiPolygon = newGeoDemo_MultiPolygon(e.config)
	e.CircularString = newGeoDemo_CircularString(e.config)
	e.PointJson = newGeoDemo_PointJson(e.config)
	e.LineStringJson = newGeoDemo_LineStringJson(e.config)
	e.PolygonJson = newGeoDemo_PolygonJson(e.config)
	e.MultiPointJson = newGeoDemo_MultiPointJson(e.config)
	e.MultiLineStringJson = newGeoDemo_MultiLineStringJson(e.config)
	e.MultiPolygonJson = newGeoDemo_MultiPolygonJson(e.config)
	return e
}

func (c *geoentityConfig) Desc() internal.EntityConfigDesc {
	return internal.EntityConfigDesc{
		Name: c.name,
	}
}

// String implements the fmt.Stringer interface.
func (e *GeoEntity) String() string {
	return fmt.Sprintf("{ Id: %v, Point: %v, LineString: %v, Polygon: %v, MultiPoint: %v, MultiLineString: %v, MultiPolygon: %v, CircularString: %v, PointJson: %v, LineStringJson: %v, PolygonJson: %v, MultiPointJson: %v, MultiLineStringJson: %v, MultiPolygonJson: %v}",
		e.Id,
		e.Point,
		e.LineString,
		e.Polygon,
		e.MultiPoint,
		e.MultiLineString,
		e.MultiPolygon,
		e.CircularString,
		e.PointJson,
		e.LineStringJson,
		e.PolygonJson,
		e.MultiPointJson,
		e.MultiLineStringJson,
		e.MultiPolygonJson,
	)
}

// State returns the state of the GeoEntity.
func (e *GeoEntity) State() entity.EntityState {
	return e.config.State()
}

// remove removes the GeoEntity from the database.
func (e *GeoEntity) remove() error {
	return e.setState(entity.Deleted)
}

// create creates a new GeoEntity and adds tracking.
func (e *GeoEntity) create(options ...func(*GeoEntity)) (*GeoEntity, error) {
	e.setState(entity.Added)
	for _, option := range options {
		option(e)
	}
	return e, nil
}

// setUnchanged sets the state of the GeoEntity to unchanged.
func (e *GeoEntity) setUnchanged() error {
	return e.setState(entity.Unchanged)
}

// setState sets the state of the GeoEntity.
func (e *GeoEntity) setState(state entity.EntityState) error {
	return e.config.geoentityMutations.SetEntityState(e, state)
}

// scan scans the database for the GeoEntity.
func (e *GeoEntity) scan(fields []entitysql.ScannerField) []any {
	if len(fields) == 0 {
		args := make([]any, len(geo_demo.Columns))
		for i, c := range geo_demo.Columns {
			switch c.String() {
			case geo_demo.FieldID.Name.String():
				v := e.Id
				v.Set(*new(int64))
				args[i] = v
			case geo_demo.FieldPoint.Name.String():
				v := e.Point
				v.Set(*new(*geo.Point))
				args[i] = v
			case geo_demo.FieldLineString.Name.String():
				v := e.LineString
				v.Set(*new(*geo.LineString))
				args[i] = v
			case geo_demo.FieldPolygon.Name.String():
				v := e.Polygon
				v.Set(*new(*geo.Polygon))
				args[i] = v
			case geo_demo.FieldMultiPoint.Name.String():
				v := e.MultiPoint
				v.Set(*new(*geo.MultiPoint))
				args[i] = v
			case geo_demo.FieldMultiLineString.Name.String():
				v := e.MultiLineString
				v.Set(*new(*geo.MultiLineString))
				args[i] = v
			case geo_demo.FieldMultiPolygon.Name.String():
				v := e.MultiPolygon
				v.Set(*new(*geo.MultiPolygon))
				args[i] = v
			case geo_demo.FieldCircularString.Name.String():
				v := e.CircularString
				v.Set(*new(*geo.CircularString))
				args[i] = v
			case geo_demo.FieldPointJson.Name.String():
				v := e.PointJson
				v.Set(*new(*geo.Point))
				args[i] = v
			case geo_demo.FieldLineStringJson.Name.String():
				v := e.LineStringJson
				v.Set(*new(*geo.LineString))
				args[i] = v
			case geo_demo.FieldPolygonJson.Name.String():
				v := e.PolygonJson
				v.Set(*new(*geo.Polygon))
				args[i] = v
			case geo_demo.FieldMultiPointJson.Name.String():
				v := e.MultiPointJson
				v.Set(*new(*geo.MultiPoint))
				args[i] = v
			case geo_demo.FieldMultiLineStringJson.Name.String():
				v := e.MultiLineStringJson
				v.Set(*new(*geo.MultiLineString))
				args[i] = v
			case geo_demo.FieldMultiPolygonJson.Name.String():
				v := e.MultiPolygonJson
				v.Set(*new(*geo.MultiPolygon))
				args[i] = v
			}
		}
		return args
	} else {
		args := make([]any, len(fields))
		for i := range fields {
			switch fields[i].String() {
			case geo_demo.FieldID.Name.String():
				v := e.Id
				v.Set(*new(int64))
				args[i] = v
			case geo_demo.FieldPoint.Name.String():
				v := e.Point
				v.Set(*new(*geo.Point))
				args[i] = v
			case geo_demo.FieldLineString.Name.String():
				v := e.LineString
				v.Set(*new(*geo.LineString))
				args[i] = v
			case geo_demo.FieldPolygon.Name.String():
				v := e.Polygon
				v.Set(*new(*geo.Polygon))
				args[i] = v
			case geo_demo.FieldMultiPoint.Name.String():
				v := e.MultiPoint
				v.Set(*new(*geo.MultiPoint))
				args[i] = v
			case geo_demo.FieldMultiLineString.Name.String():
				v := e.MultiLineString
				v.Set(*new(*geo.MultiLineString))
				args[i] = v
			case geo_demo.FieldMultiPolygon.Name.String():
				v := e.MultiPolygon
				v.Set(*new(*geo.MultiPolygon))
				args[i] = v
			case geo_demo.FieldCircularString.Name.String():
				v := e.CircularString
				v.Set(*new(*geo.CircularString))
				args[i] = v
			case geo_demo.FieldPointJson.Name.String():
				v := e.PointJson
				v.Set(*new(*geo.Point))
				args[i] = v
			case geo_demo.FieldLineStringJson.Name.String():
				v := e.LineStringJson
				v.Set(*new(*geo.LineString))
				args[i] = v
			case geo_demo.FieldPolygonJson.Name.String():
				v := e.PolygonJson
				v.Set(*new(*geo.Polygon))
				args[i] = v
			case geo_demo.FieldMultiPointJson.Name.String():
				v := e.MultiPointJson
				v.Set(*new(*geo.MultiPoint))
				args[i] = v
			case geo_demo.FieldMultiLineStringJson.Name.String():
				v := e.MultiLineStringJson
				v.Set(*new(*geo.MultiLineString))
				args[i] = v
			case geo_demo.FieldMultiPolygonJson.Name.String():
				v := e.MultiPolygonJson
				v.Set(*new(*geo.MultiPolygon))
				args[i] = v
			}
		}
		return args
	}
}

func (e *GeoEntity) createRel(buidler *entitysql.ScannerBuilder, scanner *internal.QueryScanner) {
	switch scanner.Config.Desc().Name {
	}
}

func mergeGeoEntity(es []*GeoEntity, e *GeoEntity) []*GeoEntity {
	if e == nil {
		return es
	}
	if len(es) == 0 {
		es = append(es, e)
	} else {
		v := es[len(es)-1]

		if v.Id.Get() == e.Id.Get() {
		} else {
			es = append(es, e)
		}
	}
	return es
}
